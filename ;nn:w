import numpy as np
import logging
from geometry.geometry_entities import Vertex, Edge, Facet, Body
import sys
logger = logging.getLogger("membrane_solver")

def refine_polygonal_facets(vertices, edges, facets, bodies):
    # TODO: option for loop "r2" will refine twice
    """
    Refines all non-triangular facets by subdividing them into triangles using
    centroid-based fan triangulation. Triangles remain unchanged.

    Returns:
        (updated_vertices, updated_facets)
    """
    new_vertices = vertices[:]
    new_edges = edges[:]
    new_facets = []
    next_edge_idx = max(e.index for e in new_edges) + 1

    # Prepare a map from old facet idx → list of new child facet idxs:
    children_map = {facet.index: [] for facet in facets}

    for facet in facets:
        # 1. Leave triangles alone
        if len(facet.edges) == 3:
            new_facets.append(facet)
            continue

        # 2. Reconstruct the boundary loop of vertex‐indice
        vertex_loop = [facet.edges[0].tail]
        for edge in facet.edges:
            if vertex_loop[-1] != edge.tail:
                raise ValueError(f"Edge loop is not continuous in facet {facet.index}")
            vertex_loop.append(edge.head)

        if vertex_loop[0] == vertex_loop[-1]:
            vertex_loop.pop()

        if len(vertex_loop) < 3:
            logger.warning(f"Facet {facet.index} has <3 vertices after reconstruction.")
            continue

        # 3. Create centroid
        centroid_pos = np.mean([v.position for v in vertex_loop], axis=0)
        centroid_idx = len(new_vertices)
        centroid_vertex = Vertex(position=centroid_pos, index=centroid_idx)
        new_vertices.append(centroid_vertex)

        # 4. build exactly one spoke edge per vertex in that loop
        spokes = {} # maps vertex_idx -> the Edge( vertex -> centroid )
        for vi in vertex_loop:
            # TODO: deal with how edges inherit options from facets
            e = Edge(vi, centroid_vertex, index=next_edge_idx,
                    options=facet.options.copy())
            next_edge_idx += 1
            new_edges.append(e)
            spokes[vi] = e

        # 5. now fan‐triangulate: each triangle uses
        #    - the old boundary edge
        #    - the spoke from b -> centroid
        #    - the spoke from centroid -> a  (just flip the first spoke)
        n = len(vertex_loop)
        for i in range(n):
            a = vertex_loop[i]
            b = vertex_loop[(i + 1) % n]

            # find the original boundary edge object
            # (it’s in facet.edges[i], by construction)
            boundary_edge = facet.edges[i]

            # the two spokes: b→centroid and centroid→a
            spoke_b = spokes[b]
            spoke_a = spokes[a]
            # make sure the second spoke is oriented centroid→a:
            # TODO: POSSIBLE PROBLEM WITH USING ABSOLUTE VALUE FOR INDEX AND NOT REVERSED
            rev_spoke_a = Edge(new_vertices[centroid_idx], a,
                           index=spoke_a.index,
                           options=spoke_a.options.copy())

            # build the new facet’s edge‐list **in the correct orientation**:
            child_edges = [boundary_edge, spoke_b, rev_spoke_a]
            child_idx = len(new_facets)
            child_options = facet.options.copy()
            child_options["parent_facet"] = facet.index

            child_facet = Facet(child_edges,
                                    index=child_idx,
                                    options=child_options)
            new_facets.append(child_facet)
            # Record that this child belongs to the same bodies
            children_map[facet.index].append(child_idx)

    # TODO: Associate facets with bodies! If no body exists skip
    new_bodies = []
    for body in bodies:
        new_list = []
        for facet in body.facets:
            if facet.index in children_map:
                # replaced by its child facets
                new_list.extend(children_map[facet.index])
            else:
                # the facet stayed the same (triangles)
                new_list.append(facet)

        # ideally your Body ctor also carries over volume, constraints, etc.
        new_facet_list = [new_facets[i] for i in new_list]
        new_bodies.append( Body(new_facet_list, index=body.index,
                                options=body.options.copy()) )

    assert all(isinstance(f, Facet) for f in new_facets), "new_facets still nested!"
    return new_vertices, new_edges, new_facets, new_bodies
def refine_triangle_mesh(vertices, edges, facets, bodies):
    """
    Refines each triangular Facet into four smaller triangles by:
      1) inserting one new Vertex at the midpoint of each Edge
      2) re-using or creating exactly one new Edge between every pair of
         (old-vertex, midpoint) or (midpoint, midpoint)
      3) assembling four new Facet instances to replace the old one
      4) rewiring Bodies so all old‐facet indices are replaced by their 4 children
    """
    # 1) make shallow copies of input lists
    new_vertices = list(vertices)
    new_edges    = list(edges)
    new_facets   = []
    next_edge_idx = max((e.index for e in new_edges), default=-1) + 1

    # 2) compute one midpoint-vertex per existing edge
    #    store in a dict:   old_edge -> new Vertex instance
    edge_midpoint = {}
    for e in new_edges:
        # skip if already done
        if e in edge_midpoint:
            continue
        v_tail = new_vertices[e.tail.index]
        v_head = new_vertices[e.head.index]
        midpos = (v_tail.position + v_head.position) / 2
        mid_idx = len(new_vertices)
        midpoint = Vertex(position=midpos, index=mid_idx)
        new_vertices.append(midpoint)
        edge_midpoint[e] = midpoint

    # 3) helper to get or create exactly one Edge instance between two vertex-indices
    def get_or_create_edge(tail_idx, head_idx):
        nonlocal next_edge_idx
        # search existing (either orientation)
        for e in new_edges:
            if (e.tail, e.head) == (tail_idx, head_idx) or \
               (e.tail, e.head) == (head_idx, tail_idx):
                return e
        # not found => append a new one
        e = Edge(
            tail   = tail_idx,
            head   = head_idx,
            index  = next_edge_idx,
            options= {}               # or copy your default facet.options
        )
        new_edges.append(e)
        next_edge_idx += 1
        return e

    # 4) we'll need to know which new facets came from each old one
    children_map = {f.index: [] for f in facets}

    # 5) now fan‐triangulate each old triangle into four small ones
    for facet in facets:
        assert len(facet.edges) == 3, "refine_triangle_mesh only handles triangle facets"

        # rebuild the vertex‐loop [a,b,c]
        loop = [facet.edges[0].tail]
        for e in facet.edges:
            if loop[-1] != e.tail:
                raise ValueError(f"Facet {facet.index} has broken edge loop")
            loop.append(e.head)
        if loop[0] == loop[-1]:
            loop.pop()
        a, b, c = loop  # exactly three

        # pull out our three midpoint vertices
        Mab = edge_midpoint[facet.edges[0]]
        Mbc = edge_midpoint[facet.edges[1]]
        Mca = edge_midpoint[facet.edges[2]]

        # now define the four child triangles by their vertex‐triples
        tris = [
            ( a,   Mab.index, Mca.index),
            ( b,   Mbc.index, Mab.index),
            ( c,   Mca.index, Mbc.index),
            (Mab.index, Mbc.index, Mca.index),
        ]

        # build them
        for v0, v1, v2 in tris:
            e0 = get_or_create_edge(v0, v1)
            e1 = get_or_create_edge(v1, v2)
            e2 = get_or_create_edge(v2, v0)

            child_idx = len(new_facets)
            opts = facet.options.copy()
            opts["parent_facet"] = facet.index

            new_f = Facet(edges=[e0, e1, e2],
                          index=child_idx,
                          options=opts)
            new_facets.append(new_f)
            children_map[facet.index].append(child_idx)

    # 6) rebuild bodies: every old facet index is replaced by its 4 children
    new_bodies = []
    for body in bodies:
        new_list = []
        for old_fidx in body.facets:
            if old_fidx in children_map:
                new_list.extend(children_map[old_fidx])
            else:
                new_list.append(old_fidx)
        # build the updated Body
        new_bodies.append(
            Body(new_list,
                 index   = body.index,
                 options = body.options.copy())
        )

    return new_vertices, new_edges, new_facets, new_bodies

